// Generated by Haxe 4.3.6
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var tetris_Main = function() { };
tetris_Main.main = function() {
	new tetris_pixi_PixiImpl();
};
var tetris_game_Block = function(x,y) {
	this.x = x;
	this.y = y;
};
var tetris_game_Board = function(width,height) {
	this.gridWidth = width;
	this.gridHeight = height;
	this._grid = [];
};
tetris_game_Board.prototype = {
	applyTetromino: function(tetromino) {
		var _g = 0;
		var _g1 = tetromino.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			var x = tetromino.x + block.x;
			var y = tetromino.y + block.y;
			this._grid[y * this.gridHeight + x] = tetromino.color;
		}
		var checkedRow = -1;
		var _g = 0;
		var _g1 = tetromino.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			var y = tetromino.y + block.y;
			if(y > checkedRow) {
				var collapse = true;
				var _g2 = 0;
				var _g3 = this.gridWidth;
				while(_g2 < _g3) {
					var x = _g2++;
					if(this.getBlockState(x,y) == 0) {
						collapse = false;
						break;
					}
				}
				if(collapse) {
					this.collapseRow(y);
				}
			}
			checkedRow = y;
		}
	}
	,collapseRow: function(rowY) {
		var _g = 0;
		var _g1 = this.gridWidth;
		while(_g < _g1) {
			var x = _g++;
			this._grid[rowY * this.gridHeight + x] = 0;
		}
		var _g = 0;
		var _g1 = this.gridWidth;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = rowY - 1;
			while(_g2 < _g3) {
				var y = _g2++;
				this._grid[(rowY - y) * this.gridHeight + x] = this._grid[(rowY - y - 1) * this.gridHeight + x];
				this._grid[(rowY - y - 1) * this.gridHeight + x] = 0;
			}
		}
		if(this.onRowCollapsed != null) {
			this.onRowCollapsed(rowY);
		}
	}
	,getBlockState: function(x,y) {
		var state = this._grid[y * this.gridHeight + x];
		if(state != null) {
			return state;
		} else {
			return 0;
		}
	}
	,checkPosition: function(x,y) {
		if(this.getBlockState(x,y) == 0 && x >= 0 && x < this.gridWidth) {
			return y < this.gridHeight;
		} else {
			return false;
		}
	}
};
var tetris_game_TetrisGame = function(renderer) {
	this._renderer = renderer;
	this.initGame();
};
tetris_game_TetrisGame.prototype = {
	initGame: function() {
		var _gthis = this;
		this._board = new tetris_game_Board(10,20);
		this._totalTime = 0;
		this._lastMoveTime = 0;
		this._moveGap = 5.0;
		this._gameOver = false;
		this._score = 0;
		this._current = tetris_game_Tetromino.newRandom(this._board.gridWidth);
		this._renderer.updateScore(0);
		this._board.onRowCollapsed = function(rowY) {
			_gthis._score++;
			_gthis._renderer.updateScore(_gthis._score);
		};
	}
	,loop: function(deltaTime) {
		this._totalTime += deltaTime;
		var input = this._renderer.pollEvents();
		if(this._gameOver) {
			if(input.anyKey) {
				this.initGame();
				return;
			}
			this._renderer.drawGameOver();
			return;
		}
		if(input.rotateCw) {
			this._current.rotateCw();
			var _g = 0;
			var _g1 = this._current.blocks;
			while(_g < _g1.length) {
				var block = _g1[_g];
				++_g;
				if(!this._board.checkPosition(this._current.x + block.x,this._current.y + block.y)) {
					this._current.rotateCcw();
					break;
				}
			}
		}
		if(input.rotateCcw) {
			this._current.rotateCcw();
			var _g = 0;
			var _g1 = this._current.blocks;
			while(_g < _g1.length) {
				var block = _g1[_g];
				++_g;
				if(!this._board.checkPosition(this._current.x + block.x,this._current.y + block.y)) {
					this._current.rotateCw();
					break;
				}
			}
		}
		var movement = 0;
		if(input.moveLeft) {
			--movement;
		}
		if(input.moveRight) {
			++movement;
		}
		if(movement != 0) {
			this._current.x += movement;
			var _g = 0;
			var _g1 = this._current.blocks;
			while(_g < _g1.length) {
				var block = _g1[_g];
				++_g;
				if(!this._board.checkPosition(this._current.x + block.x,this._current.y + block.y)) {
					this._current.x -= movement;
					break;
				}
			}
		}
		if(input.moveDown) {
			this._lastMoveTime = this._totalTime;
			if(!this.move()) {
				this._current.y++;
			}
		} else if(this._totalTime >= this._lastMoveTime + this._moveGap) {
			if(!this.move()) {
				this._current.y++;
			}
			this._lastMoveTime += this._moveGap;
		}
		if(this._gameOver) {
			return;
		}
		this._renderer.drawBoard(this._board);
		this._renderer.drawTetromino(this._current);
	}
	,move: function() {
		var blocks = this._current.blocks;
		var _g = 0;
		var _g1 = blocks.length;
		while(_g < _g1) {
			var i = _g++;
			if(this._current.y + blocks[i].y == this._board.gridHeight - 1) {
				this.onReachedBottom();
				return true;
			}
			if(this._current.y < this._board.gridHeight - 1 && !this._board.checkPosition(this._current.x + blocks[i].x,this._current.y + blocks[i].y + 1)) {
				this.onReachedBottom();
				return true;
			}
		}
		return false;
	}
	,onReachedBottom: function() {
		this._board.applyTetromino(this._current);
		this._current = tetris_game_Tetromino.newRandom(this._board.gridWidth);
		var _g = 0;
		var _g1 = this._current.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			if(!this._board.checkPosition(this._current.x + block.x,this._current.y + block.y)) {
				this._gameOver = true;
				return;
			}
		}
	}
};
var tetris_game_TetrisInput = function() {
	this.anyKey = false;
	this.moveRight = false;
	this.moveLeft = false;
	this.moveDown = false;
	this.rotateCw = false;
	this.rotateCcw = false;
};
var tetris_game_TetrominoColors = function() { };
var tetris_game_Tetromino = function(startX,startY,blocks,color,matrixSize) {
	if(matrixSize == null) {
		matrixSize = 3;
	}
	this.blocks = blocks;
	this.color = color;
	this.x = startX;
	this.y = startY;
	this.matrixSize = matrixSize;
};
tetris_game_Tetromino.newRandom = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var randomNumber = Math.floor(Math.random() * 7) + 1;
	switch(randomNumber) {
	case 1:
		return tetris_game_Tetromino.newO(boardWidth);
	case 2:
		return tetris_game_Tetromino.newI(boardWidth);
	case 3:
		return tetris_game_Tetromino.newS(boardWidth);
	case 4:
		return tetris_game_Tetromino.newZ(boardWidth);
	case 5:
		return tetris_game_Tetromino.newL(boardWidth);
	case 6:
		return tetris_game_Tetromino.newJ(boardWidth);
	case 7:
		return tetris_game_Tetromino.newT(boardWidth);
	default:
		return null;
	}
};
tetris_game_Tetromino.newO = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2) - 1;
	var blocks = [new tetris_game_Block(0,0),new tetris_game_Block(0,1),new tetris_game_Block(1,0),new tetris_game_Block(1,1)];
	return new tetris_game_Tetromino(startX,-1,blocks,tetris_game_TetrominoColors.Yellow,2);
};
tetris_game_Tetromino.newI = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(1,0),new tetris_game_Block(1,1),new tetris_game_Block(1,2),new tetris_game_Block(1,3)];
	return new tetris_game_Tetromino(startX,-3,blocks,tetris_game_TetrominoColors.Aqua,4);
};
tetris_game_Tetromino.newS = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(0,1),new tetris_game_Block(1,0),new tetris_game_Block(1,1),new tetris_game_Block(2,0)];
	return new tetris_game_Tetromino(startX,-1,blocks,tetris_game_TetrominoColors.Red);
};
tetris_game_Tetromino.newZ = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(0,0),new tetris_game_Block(1,0),new tetris_game_Block(1,1),new tetris_game_Block(2,1)];
	return new tetris_game_Tetromino(startX,-1,blocks,tetris_game_TetrominoColors.Green);
};
tetris_game_Tetromino.newL = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(0,0),new tetris_game_Block(0,1),new tetris_game_Block(0,2),new tetris_game_Block(1,2)];
	return new tetris_game_Tetromino(startX,-2,blocks,tetris_game_TetrominoColors.Orange);
};
tetris_game_Tetromino.newJ = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(0,2),new tetris_game_Block(1,0),new tetris_game_Block(1,1),new tetris_game_Block(1,2)];
	return new tetris_game_Tetromino(startX,-2,blocks,tetris_game_TetrominoColors.Blue);
};
tetris_game_Tetromino.newT = function(boardWidth) {
	if(boardWidth == null) {
		boardWidth = 10;
	}
	var startX = Math.round(boardWidth / 2 - 1);
	var blocks = [new tetris_game_Block(0,1),new tetris_game_Block(1,1),new tetris_game_Block(1,2),new tetris_game_Block(2,1)];
	return new tetris_game_Tetromino(startX,-2,blocks,tetris_game_TetrominoColors.Purple);
};
tetris_game_Tetromino.prototype = {
	rotateCw: function() {
		var _g = 0;
		var _g1 = this.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			var newX = this.matrixSize - 1 - block.y;
			var newY = block.x;
			block.x = newX;
			block.y = newY;
		}
	}
	,rotateCcw: function() {
		var _g = 0;
		var _g1 = this.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			var newX = block.y;
			var newY = this.matrixSize - 1 - block.x;
			block.x = newX;
			block.y = newY;
		}
	}
};
var tetris_pixi_PixiImpl = function() {
	var _gthis = this;
	this._game = new tetris_game_TetrisGame(this);
	var options = { width : tetris_pixi_PixiImpl.SCREEN_WIDTH, height : tetris_pixi_PixiImpl.SCREEN_HEIGHT, backgroundColor : tetris_pixi_PixiImpl.BG_COLOR, transparent : false, antialias : false};
	this._graphics = new PIXI.Graphics();
	this._input = new tetris_game_TetrisInput();
	PIXI.Application.call(this,options);
	this.ticker.add(function(deltaTime) {
		_gthis._game.loop(deltaTime / _gthis.ticker.FPS);
		_gthis._input = new tetris_game_TetrisInput();
	});
	this.stage.addChild(this._graphics);
	this.view.id = "canvas";
	window.document.body.appendChild(this.view);
	window.addEventListener("keydown",$bind(this,this.onKeyDown),true);
};
tetris_pixi_PixiImpl.__super__ = PIXI.Application;
tetris_pixi_PixiImpl.prototype = $extend(PIXI.Application.prototype,{
	drawBoard: function(board) {
		this._graphics.clear();
		if(this._gameOverLabel != null) {
			this.stage.removeChild(this._gameOverLabel);
			this._gameOverLabel = null;
		}
		if(this._scoreLabel == null) {
			var headerHeight = 24;
			var style = { };
			style.fill = 16777215;
			style.fontSize = 18;
			style.align = "left";
			style.fontWeight = "400";
			this._scoreLabel = new PIXI.Text("SCORE: " + this._score,style);
			this._scoreLabel.position.set(4,2 + headerHeight / 2.0 - this._scoreLabel.height / 2.0);
			this.stage.addChild(this._scoreLabel);
		}
		var _g = 0;
		var _g1 = board.gridWidth;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = board.gridHeight;
			while(_g2 < _g3) {
				var y = _g2++;
				var state = board.getBlockState(x,y);
				this.drawBlock(x,y,state);
			}
		}
	}
	,drawTetromino: function(tetromino) {
		var _g = 0;
		var _g1 = tetromino.blocks;
		while(_g < _g1.length) {
			var block = _g1[_g];
			++_g;
			this.drawBlock(tetromino.x + block.x,tetromino.y + block.y,tetromino.color);
		}
		this._graphics.beginFill(2566443,1);
		this._graphics.drawRect(0,0,tetris_pixi_PixiImpl.SCREEN_WIDTH,26);
		this._graphics.endFill();
	}
	,drawBlock: function(x,y,state) {
		var outerSize = 36;
		var innerSize = 32;
		var outerX = 2 + x * outerSize;
		var outerY = 28 + y * outerSize;
		var innerX = outerX + outerSize / 2 - innerSize / 2;
		var innerY = outerY + outerSize / 2 - innerSize / 2;
		this._graphics.beginFill(state == 0 ? 1447962 : state,1);
		this._graphics.drawRect(innerX,innerY,innerSize,innerSize);
		this._graphics.endFill();
	}
	,pollEvents: function() {
		return this._input;
	}
	,onKeyDown: function(e) {
		this._input.anyKey = true;
		if(e.keyCode == 65 || e.keyCode == 37) {
			this._input.moveLeft = true;
		}
		if(e.keyCode == 68 || e.keyCode == 39) {
			this._input.moveRight = true;
		}
		if(e.keyCode == 83 || e.keyCode == 40) {
			this._input.moveDown = true;
		}
		if(e.keyCode == 88 || e.keyCode == 87) {
			this._input.rotateCw = true;
		}
		if(e.keyCode == 90) {
			this._input.rotateCcw = true;
		}
	}
	,drawGameOver: function() {
		if(this._gameOverLabel != null) {
			this.stage.removeChild(this._scoreLabel);
			this._scoreLabel = null;
		}
		if(this._gameOverLabel == null) {
			this._graphics.clear();
			var style = { };
			style.fill = 16777215;
			style.fontSize = 32;
			style.align = "center";
			this._gameOverLabel = new PIXI.Text("GAME OVER\nSCORE:" + this._score + "\nPRESS ANY KEY\nTO RESTART",style);
			this._gameOverLabel.position.set(tetris_pixi_PixiImpl.SCREEN_WIDTH / 2 - this._gameOverLabel.width / 2,tetris_pixi_PixiImpl.SCREEN_HEIGHT / 2 - this._gameOverLabel.height / 2);
			this.stage.addChild(this._gameOverLabel);
		}
	}
	,updateScore: function(score) {
		this._score = score;
		if(this._scoreLabel != null) {
			this._scoreLabel.text = "SCORE: " + this._score;
		}
	}
});
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
tetris_game_TetrominoColors.Aqua = 65535;
tetris_game_TetrominoColors.Yellow = 16776960;
tetris_game_TetrominoColors.Purple = 8388736;
tetris_game_TetrominoColors.Green = 65280;
tetris_game_TetrominoColors.Red = 16711680;
tetris_game_TetrominoColors.Blue = 255;
tetris_game_TetrominoColors.Orange = 16744192;
tetris_pixi_PixiImpl.SCREEN_WIDTH = 364;
tetris_pixi_PixiImpl.SCREEN_HEIGHT = 750;
tetris_pixi_PixiImpl.BG_COLOR = 328965;
tetris_Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
